<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>PagedJS Preview</title>
        <style>
            :root {
                --preview-zoom-scale: 1;
            }

            body {
                margin: 0;
                padding: 0;
            }

            /* Hide the preview while it's rendering */
            .preview-hidden {
                position: absolute;
                top: 0;
                left: 0;
                visibility: hidden;
                transform: translateX(-10000px); /* move it out of view to avoid scrollbar flickering during render */
            }

            .preview-visible {
                position: relative;
                visibility: visible;
                transform: none;
            }

            /* PagedJS default styles */
            .pagedjs_pages {
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                margin: calc(3.5rem / var(--preview-zoom-scale, 1)) 0 5px 0; /* top margin is calculated from zoom scale to be the same visually at any zoom level */
            }
            .pagedjs_page {
                margin: 5px auto;
                background: white;
                box-shadow:
                    0px 0px 0px 1px rgba(0, 0, 0, 0.06),
                    0 0 20px -1px rgba(0, 0, 0, 0.08);
            }
        </style>

        <script src="{{PAGED_JS_URL}}"></script>

        <script>
            let currentRenderId = 0;
            let isRendering = false;
            let queuedRender = null;
            let lastInsertedStyles = [];

            // The main render function called from the parent
            window.renderPreview = async (html, css) => {
                // If we are already rendering, queue this request
                if (isRendering) {
                    queuedRender = { html, css };
                    return;
                }

                isRendering = true;
                const renderId = ++currentRenderId;

                // Ensure at least one page is rendered even if HTML is empty
                if (!html || !html.trim()) {
                    html = "&nbsp;";
                }

                try {
                    // 1. Prepare styles
                    // We pass the CSS as an "inline" stylesheet to PagedJS.
                    // This ensures PagedJS parses @page rules using its Polisher.
                    // We use a dummy URL or the current location as the key for the object format.
                    const cssContent = "@page { margin: 0.4in; } " + css;
                    const stylesheets = [{ [window.location.href]: cssContent }];

                    // 2. Create a new container for this render
                    const root = document.body;
                    const container = document.createElement("div");
                    container.classList.add("preview-hidden");
                    // We need to append it to the body so PagedJS can calculate layout
                    root.appendChild(container);

                    // 3. Run PagedJS
                    if (window.Paged && window.Paged.Previewer) {
                        const previewer = new window.Paged.Previewer();

                        // We pass the stylesheets explicitly.
                        // PagedJS will parse them with Polisher and insert transformed styles into <head>.
                        await previewer.preview('<div id="print-root">' + html + "</div>", stylesheets, container);

                        // 4. If this is still the latest render, show it
                        if (renderId === currentRenderId) {
                            // Remove all other children (previous renders)
                            Array.from(root.children).forEach((child) => {
                                if (child !== container && child.tagName === "DIV") {
                                    child.remove();
                                }
                            });

                            container.classList.remove("preview-hidden");
                            container.classList.add("preview-visible");

                            // Make links open in a new tab and ensure they are absolute
                            // TODO: Test this further, make sure it covers all scenarios
                            const anchors = container.querySelectorAll("a[href]");
                            anchors.forEach((anchor) => {
                                let href = anchor.getAttribute("href").trim();
                                if (!href) return;

                                // Check if the link starts with a protocol or a slash (for internal/relative)
                                // We use a regex to see if it starts with "http://", "https://", "mailto:", etc.
                                const hasProtocol = /^[a-z0-9]+:/i.test(href);
                                const isRelative = href.startsWith("/") || href.startsWith("#");

                                if (!hasProtocol && !isRelative) {
                                    href = "https://" + href;
                                    anchor.setAttribute("href", href);
                                }
                                if (!isRelative) {
                                    anchor.setAttribute("target", "_blank");
                                    anchor.setAttribute("rel", "noopener noreferrer");
                                }
                            });

                            // Cleanup styles from the PREVIOUS successful render
                            if (lastInsertedStyles && lastInsertedStyles.length > 0) {
                                lastInsertedStyles.forEach((style) => {
                                    if (style.parentNode) style.remove();
                                });
                            }

                            // Save the styles from THIS render to be cleaned up next time
                            // previewer.polisher.inserted contains the <style> elements added to head
                            lastInsertedStyles = previewer.polisher.inserted;
                        } else {
                            // This render is stale, discard it
                            container.remove();

                            // Also remove the styles this stale render added!
                            if (previewer.polisher.inserted) {
                                previewer.polisher.inserted.forEach((style) => {
                                    if (style.parentNode) style.remove();
                                });
                            }
                        }
                    }
                } catch (err) {
                    console.error("PagedJS render error:", err);
                } finally {
                    isRendering = false;
                    // If there's a queued render, run it now
                    if (queuedRender) {
                        const { html, css } = queuedRender;
                        queuedRender = null;
                        window.renderPreview(html, css);
                    }
                }
            };
        </script>
    </head>
    <body></body>
</html>
